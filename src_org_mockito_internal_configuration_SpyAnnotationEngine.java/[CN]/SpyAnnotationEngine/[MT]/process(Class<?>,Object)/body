{
  Field[] fields=context.getDeclaredFields();
  for (  Field field : fields) {
    if (field.isAnnotationPresent(Spy.class) && !field.isAnnotationPresent(InjectMocks.class)) {
      assertNoIncompatibleAnnotations(Spy.class,field,Mock.class,org.mockito.MockitoAnnotations.Mock.class,Captor.class);
      field.setAccessible(true);
      Object instance=null;
      try {
        instance=field.get(testInstance);
        if (new MockUtil().isMock(instance)) {
          Mockito.reset(instance);
        }
 else         if (instance != null) {
          field.set(testInstance,Mockito.mock(instance.getClass(),withSettings().spiedInstance(instance).defaultAnswer(Mockito.CALLS_REAL_METHODS).name(field.getName())));
        }
 else {
          MockSettings settings=withSettings().useConstructor().defaultAnswer(Mockito.CALLS_REAL_METHODS).name(field.getName());
          if (field.getType().getEnclosingClass() != null && !Modifier.isStatic(field.getType().getModifiers()) && field.getType().getEnclosingClass().isInstance(testInstance)) {
            settings.outerInstance(testInstance);
          }
          field.set(testInstance,Mockito.mock(field.getType(),settings));
        }
      }
 catch (      IllegalAccessException e) {
        throw new MockitoException("Problems initiating spied field " + field.getName(),e);
      }
    }
  }
}
