{
  if (mockitoStubber.hasAnswersForStubbing()) {
    Invocation invocation=new Invocation(proxy,method,args,SequenceNumber.next(),new FilteredCGLIBProxyRealMethod(methodProxy));
    InvocationMatcher invocationMatcher=matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),invocation);
    mockitoStubber.setMethodForStubbing(invocationMatcher);
    return null;
  }
  VerificationMode verificationMode=mockingProgress.pullVerificationMode();
  Invocation invocation=new Invocation(proxy,method,args,SequenceNumber.next(),new FilteredCGLIBProxyRealMethod(methodProxy));
  InvocationMatcher invocationMatcher=matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),invocation);
  mockingProgress.validateState();
  if (verificationMode != null) {
    VerificationDataImpl data=new VerificationDataImpl(registeredInvocations.getAll(),invocationMatcher);
    verificationMode.verify(data);
    return null;
  }
  registeredInvocations.add(invocationMatcher.getInvocation());
  mockitoStubber.setInvocationForPotentialStubbing(invocationMatcher);
  OngoingStubbingImpl<T> ongoingStubbing=new OngoingStubbingImpl<T>(mockitoStubber,registeredInvocations);
  mockingProgress.reportOngoingStubbing(ongoingStubbing);
  Answer<?> stubbedAnswer=mockitoStubber.findAnswerFor(invocation);
  if (!invocation.isVoid() && stubbedAnswer == null) {
    mockingProgress.getDebuggingInfo().addPotentiallyUnstubbed(invocationMatcher);
  }
  if (stubbedAnswer != null) {
    mockingProgress.getDebuggingInfo().reportUsedStub(invocationMatcher);
    return stubbedAnswer.answer(invocation);
  }
 else {
    Object ret=mockSettings.getDefaultAnswer().answer(invocation);
    mockitoStubber.setInvocationForPotentialStubbing(invocationMatcher);
    return ret;
  }
}
